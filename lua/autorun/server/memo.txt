
class Face = {
	HalfEdge OuterComponent,
	HalfEdge[] InnerComponent,
}

class HalfEdge = {
	Vector Origin,
	HalfEdge Twin,
	Face IncidentFace,
	HalfEdge Next,
	HalfEdge Prev,
}

class DCEL = {
	Faces = {
		Face f1,
		Face f2,
		...
	}
	HalfEdges = {
		HalfEdge e1,
		HalfEdge e2,
		...
	}
}

table InkGroup = {
	[surface_id1] = { --Base expression of ink
		Faces = {
			fNULL = {                   f1 = {
				OuterComponent = e4,    	OuterComponent = e1,
				InnerComponent = NULL,  	InnerComponent = NULL,
				Tag = {},               	Tag = {},
			}                           }
		},
		HalfEdges = { --WorldToLocal()'d, neworigin = surface.center, newangle = surface.normal:Angle()
			e1 = {              e2 = {              e3 = {
				origin = p1,    	origin = p2,    	origin = p3 = Vector(0, py3, pz3),
				twin = e4,      	twin = e5,      	twin = e6,
				face = f1,      	face = f1,      	face = f1,
				next = e2,      	next = e3,      	next = e1,
				prev = e3,      	prev = e1,      	prev = e2,
			},                  },                  },
			
			e4 = {              e5 = {              e6 = {			
				origin = p1,    	origin = p2,    	origin = p3,
				twin = e1,      	twin = e2,      	twin = e3,
				face = fNULL,   	face = fNULL,   	face = fNULL,
				next = e5,      	next = e6,      	next = e4,
				prev = e6,      	prev = e4,      	prev = e5,
			}                   }                   }
		},
}

function ProcessQueue(origin, normal, angle.roll, multiplier, color, polys)

	table polys = {
		Vector p1 = {0, py1, pz1},
		Vector p2 = {0, py2, pz2},
		Vector p3 = {0, py3, pz3},
		...
	}
	Vector normal
	Angle angle (only using its roll)
	float multiplier
	Color color
	table Reference_Polygons = polys * multiplier
		-> Convert Reference_Polygons into Doubly-Connected Edge List
	DCEL Reference_Polygons = { --Base expression of ink
		Faces = {
			fNULL = {                   f1 = {
				OuterComponent = e4,    	OuterComponent = e1,
				InnerComponent = NULL,  	InnerComponent = NULL,
				Tag = {},               	Tag = {},
				{["isground"] = true, [Color color] = true, ...}
			}                           }
		},
		HalfEdges = {
			e1 = {              e2 = {              e3 = {
				origin = p1,    	origin = p2,    	origin = p3,
				twin = e4,      	twin = e5,      	twin = e6,
				face = f1,      	face = f1,      	face = f1,
				next = e2,      	next = e3,      	next = e1,
				prev = e3,      	prev = e1,      	prev = e2,
			},                  },                  },
			
			e4 = {              e5 = {              e6 = {			
				origin = p1,    	origin = p2,    	origin = p3,
				twin = e1,      	twin = e2,      	twin = e3,
				face = fNULL,   	face = fNULL,   	face = fNULL,
				next = e5,      	next = e6,      	next = e4,
				prev = e6,      	prev = e4,      	prev = e5,
			}                   }                   }
		},
	}
	
	1. Get surface polygons from map
	table Surfaces = from map
	2. for each surf in Surfaces do
		surf = {int id, Vector[3] vertices, Vector normal, Vector center}
		DCEL surf = TODO: Convert surf into Doubly-Connected Edge List
		DCEL existink = InkGroup[surf.id]
		NewArea = ExistInk - Reference + Surface AND Reference
		DCEL NewArea = GetOverlayArea(Reference_Polygons, surf)
		NewArea = GetTaggedArea({["isground"] = true, [Color color] = true})
		//NewArea = surf AND Reference_Polygons
		
		if existink then
			existink = GetOverlayArea(existink, Reference_Polygons)
			existink = GetNotTaggedArea({[Color color] = true})
			//existink = existink - Reference_Polygons
			
			NewArea = GetOverlayArea(overlay, existink)
		end
		
		InkGroup[surf.id] = NewArea //process 2.4
		
		2.1 A = Reference_Polygons AND surf
		2.2 B = ExistInk - Reference_Polygons
		2.3 NewArea = A + B
		2.4 InkGroup[surface_id] = NewArea
		2.5 Triangulate NewArea
		2.6 Convert NewArea into MeshVertex structure
		2.7 Send it to all client
	end
	3. End processing
